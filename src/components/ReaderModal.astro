---
// Client-side only component
---

<div id="reader-modal" class="reader-modal" hidden aria-modal="true" role="dialog">
  <div class="reader-backdrop"></div>

  <article class="reader-content">
    <header class="reader-header">
      <button class="reader-close" aria-label="Close">&times;</button>
      <h1 id="reader-title"></h1>
      <div class="reader-meta">
        <span id="reader-byline"></span>
        <span id="reader-time"></span>
      </div>
      <a id="reader-original" href="#" target="_blank" rel="noopener noreferrer">
        View original &#8599;
      </a>
    </header>

    <div id="reader-body" class="reader-body"></div>
  </article>
</div>

<div id="reader-loading" class="reader-loading" hidden>
  <div class="loading-spinner"></div>
  <p>Loading article...</p>
  <button id="reader-cancel" class="action-button" style="margin-top: 1rem; color: white; border-color: rgba(255,255,255,0.3);">Cancel</button>
</div>

<script>
  const modal = document.getElementById('reader-modal');
  const loading = document.getElementById('reader-loading');
  const cancelBtn = document.getElementById('reader-cancel');

  if (modal && loading) {
    const backdrop = modal.querySelector('.reader-backdrop');
    const closeBtn = modal.querySelector('.reader-close');
    let activeController: AbortController | null = null;

    cancelBtn?.addEventListener('click', () => {
      activeController?.abort();
      loading.hidden = true;
    });

    document.addEventListener('click', async (e) => {
      const button = (e.target as Element).closest('.read-in-app');
      if (!button) return;

      e.preventDefault();
      const url = (button as HTMLElement).dataset.url;
      if (!url) return;

      await openReader(url);
    });

    async function openReader(url: string) {
      loading.hidden = false;
      modal.hidden = true;
      let success = false;

      activeController = new AbortController();
      const timeout = setTimeout(() => activeController?.abort(), 15000);

      try {
        console.log('[Reader] Fetching:', url);

        const response = await fetch(
          `/.netlify/functions/extract-article?url=${encodeURIComponent(url)}`,
          { signal: activeController.signal },
        );
        clearTimeout(timeout);

        console.log('[Reader] Response:', response.status);

        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const article = await response.json();
        if (article.error) throw new Error(article.error);

        document.getElementById('reader-title')!.textContent = article.title;
        document.getElementById('reader-byline')!.textContent = article.byline || '';
        document.getElementById('reader-time')!.textContent = article.readingTime
          ? `${article.readingTime} min read`
          : '';
        document.getElementById('reader-body')!.innerHTML = article.content;
        (document.getElementById('reader-original') as HTMLAnchorElement).href = url;

        success = true;
        console.log('[Reader] Success:', article.title);
      } catch (err) {
        console.error('[Reader] Error:', err);
      } finally {
        clearTimeout(timeout);
        activeController = null;
        loading.hidden = true;
        if (success) {
          modal.hidden = false;
          document.body.style.overflow = 'hidden';
          closeBtn?.focus();
        } else {
          window.open(url, '_blank', 'noopener,noreferrer');
        }
      }
    }

    function closeReader() {
      modal.hidden = true;
      document.body.style.overflow = '';
    }

    closeBtn?.addEventListener('click', closeReader);
    backdrop?.addEventListener('click', closeReader);

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !modal.hidden) closeReader();
      if (e.key === 'Escape' && !loading.hidden) {
        activeController?.abort();
        loading.hidden = true;
      }
    });
  }
</script>
